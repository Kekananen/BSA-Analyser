import com.sun.javafx.property.adapter.PropertyDescriptor;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;

/**
 *
 * @author Tien Tang, Kathryn Kananen
 */
public class SlidingWindows {
    
    
     public HashMap<String, HashMap<Integer, ArrayList>> CreateRegionWindows(ArrayList<String> file, int regionSizeInput, int incrementInput) { //input chromosome sequence and listen for window size input by user.
        
        //Step 1. Store each variant line and get the chromosome lengths.
        ArrayList<String> variantList = new ArrayList<String>(); //create empty arraylist to store each line as a String[]
        Iterator fileIter = file.iterator(); //iterate through file
        HashMap<String, Integer> chromLengthList = new HashMap<String, Integer>(); //store contig length
        while(fileIter.hasNext()) {
            String variant = fileIter.next().toString();
            if (variant.toString().startsWith("##contig")) {
                String chromNo = variant.split("=|,")[2];
                int length = Integer.parseInt(variant.split("=|,|>")[4]);
                chromLengthList.put(chromNo,length);
            } else if (variant.toString().startsWith("#")) {
                continue;
            } else {
                variantList.add(variant);
            }
        };
        
        //Step 2. Get window size by converting first user input (regionSizeInput) to integer
        
        //String size = regionSizeInput.toString(); //convert action to string
        //int regionSize = Integer.parseInt(size); //convert string to integer
        
        //Step 3. Get increment size by converting second user input (incrementInput) to integer.
        
        //String inc = incrementInput.toString(); //convert input to string.
        //int incSize = Integer.parseInt(inc); //convert increment size to integer.
        
        //Step 4. Get the list of chromosomes.
        
        Iterator VLIter1 = variantList.iterator(); //iterate through variant list created Step 1.
        ArrayList chromList = new ArrayList(); //blank ArrayList to store chromosome numbers.
        
        while (VLIter1.hasNext()) {
            String[] variant = VLIter1.next().toString().split("\t");
            String chromNo = variant[0];
            if(!chromList.contains(chromNo)) { //if the chromosome is not already in the ArrayList.
                chromList.add(chromNo); //then add the chromosome number to the ArrayList.
            }
        }
        
        /*Step 5.
        * Create a HashMap (finalHS) that will store the variants in each region window
        * for each chromosome.
        * Create a HashMap to store the regionWindows in (Integer regionStart,
        * ArrayList innerVariantList).
        * The ArrayList innerVariantList will store each variant line from the
        * vcf file for a given chromosome and within the regionSizeInput range.
        * 
        *
        */
        HashMap<String, HashMap<Integer, ArrayList>> finalHS = new HashMap<String,HashMap<Integer, ArrayList>>(); //create new hashmap to store regions list for all chromosomes
        HashMap<Integer, ArrayList> regionWindows = new HashMap<Integer,ArrayList>(); //create HS to store the regionWindows in, with key as the start position of the window
        
        Iterator CNIt = chromList.iterator();
        while (CNIt.hasNext()) { //for each chromosome, while there is a next.
            String chromNo = CNIt.next().toString(); //store the chromosome number
            int chromLength = chromLengthList.get(chromNo);
            Iterator VLIter2 = variantList.iterator();
                
            ArrayList<String> innerVariantList = new ArrayList<String>(); //for a single window, create an empty arraylist to store the variants.
                    
            while (VLIter2.hasNext()) { //while there is a next item to iterate to in the variant list
                String variant = VLIter2.next().toString(); //store the next variant string
                int position = Integer.parseInt(variant.split("\t")[1]); // and get the position as an integer
                for (int regionStart = 0; regionStart + regionSizeInput <= chromLength; regionStart += incrementInput) {
                if(variant.startsWith(chromNo) && position == regionStart && position <= regionStart + regionSizeInput) {
                    //add the variant to the ArrayList of regionWindows
                    innerVariantList.add(variant);
                     } else {
                    
                }
                regionWindows.put(regionStart,innerVariantList);
                }
            }
            finalHS.put(chromNo,regionWindows);
            }

        return finalHS;
    };
    
     
     /*
     *
     *
     */
     
     
    public HashMap<String, HashMap<Integer, ArrayList<Double>>> freqFinder(HashMap<String, HashMap<Integer, ArrayList<String>>> pool) {
		
                ArrayList<String> chromNoList = new ArrayList();
                Iterator chromNoIter = pool.keySet().iterator(); //iterate through chromosome keys
                /*while (chromNoIter.hasNext() && !chromNoList.contains(chromNoIter.next())) {
                chromNoList.add(chromNoIter.next().toString()); //add chromosome string if not present in list already.
                }*/
                
                
                
                // to the HashMap list relating to that chromosome with the helper function.
		HashMap<String, HashMap<Integer, ArrayList<Double>>> regionMap = new HashMap<String, HashMap<Integer, ArrayList<Double>>>();
		// Holds the values to be placed in the HashMap.
                HashMap<Integer,ArrayList<Double>> regionWindows = new HashMap<Integer,ArrayList<Double>>();
		ArrayList<Double> region = new ArrayList<Double>();
                
                while (chromNoIter.hasNext()) {

                    String chrom = chromNoIter.next().toString();
                    //System.out.println(chrom);
                    HashMap innerHS = pool.get(chrom);
                    Iterator windowIterator = innerHS.keySet().iterator();
                    while (windowIterator.hasNext()) {
                        int windowNo = Integer.parseInt(windowIterator.next().toString());
                        ArrayList<String> variantList = (ArrayList) innerHS.get(windowNo);
                        for ( String variant : variantList) {
                            String[] line = variant.split("\t");
                            //System.out.println(variant);
                            double vaf = 0;
                            if (!line[9].equals("./.")) {
                                
                                if(line[7].contains("DP=0") != true) {

							// 2.1 Calculate where in the vcf the GT and PL are kept and at what index.
							String[] varInfo = line[8].split(":");

							int GTindex = Arrays.asList(varInfo).indexOf("GT");
							int PLindex = Arrays.asList(varInfo).indexOf("PL");
							int ADindex = Arrays.asList(varInfo).indexOf("AD");
							int DPindex = Arrays.asList(varInfo).indexOf("DP");

							String GT = "", PL = "", AD = "", DP = "";
							// If the index is not 0 then get the values.

							if (GTindex != -1) {
								//EDIT: BELOW LINE BELONGED TO KAT ORIGINALLY
                                                                //GT = varInfo[GTindex];
                                                                GT = line[9].split(":")[GTindex];
							} else {
								return null;
							}
							if (PLindex != -1) {
								PL = line[9].split(":")[PLindex];
							} else {
								return null;
							}
							if (ADindex != -1) {
								//EDIT: BELOW LINE BELONGED TO KAT ORIGINALLY
                                                                //AD = varInfo[ADindex];
                                                                
                                                                //Add AD values
                                                                AD = line[9].split(":")[ADindex];
							} else {
								System.out.println("hit");
								return null;
							}
							if (DPindex != -1) {
								//EDIT: BELOW LINE BELONGED TO KAT ORIGINALLY
                                                                //DP = varInfo[ADindex];
                                                                
                                                                //Add DP values
                                                                DP = line[9].split(":")[DPindex];
							} else {
								System.out.println("hit1");
								return null;
							}

							// The variant calculated from the PL variable taking into account both
							// heterozygous counts and homozygous counts for the variant allele.
							String minor = "";
                                                        //Tien's code starts here
                                                        //If the GT is homozygous reference (0/0) then store in noWTreads
                                                        if (GT == "0/0") {
                                                        continue;
                                                        } else if (GT.split("/")[0] != GT.split("/")[1]) {
                                                            double noWTreads = (Double.parseDouble(AD.split(",")[0]))/2;
                                                            double noMutantReads = (Double.parseDouble(AD.split(",")[1]))/2;
                                                            
                                                            vaf = noMutantReads / (noWTreads + noMutantReads);
                                                            region.add(vaf);
                                                            //System.out.println(vaf);
                                                        } else {
                                                            double noMutantReads = Double.parseDouble(AD.split(",")[1]);
                                                            vaf = noMutantReads / Double.parseDouble(DP);
                                                            region.add(vaf);
                                                        }
                                                        
                                                        //Below is Kat's code. Need to adjust for AD:DP instead
                                                        
                                                        /*
                                                        if (Double.parseDouble(PL.split(",")[2]) > Double.parseDouble(PL.split(",")[0])) {
								Double var = Double.parseDouble(PL.split(",")[2])
										+ Double.parseDouble(PL.split(",")[1]) / 2;
								vaf = var / (Double.parseDouble(PL.split(",")[0]) + var);
							} else {
								Double var = Double.parseDouble(PL.split(",")[0])
										+ Double.parseDouble(PL.split(",")[1]) / 2;
								vaf = var / (Double.parseDouble(PL.split(",")[0]) + var);
							} */

						} else {
							vaf = 0;
                                                        region.add(vaf);
						}
					} else {
						vaf = 0;
                                                region.add(vaf);
					}
                                        
                                        
                                        
                                        

					//region.add(vaf);
                                        
                                        
					regionWindows.put(windowNo, region);
                                        System.out.println(regionWindows.get(windowNo));
                            }
                        
                    }
                regionMap.put(chrom, regionWindows);    
                }
                    /*
                    Iterate through chromosome keys, for each chromosome key, get each window
                     key and iterate through the list of variant lines for a given window
                     to calculate the values
                    */
         return regionMap;
                    
                }
                
	 
    /*
    *The below method calculates the average for each window.
    */
    
     private HashMap<String, HashMap<Integer, Double>> CalculateAvgMAFEstimate (HashMap<String, HashMap<Integer, ArrayList<Double>>> regionMap) {
         //Iterator
         return null;
     }

     
     
     
    /* THIS METHOD IS NOT COMPLETE YET.
    * The below method accepts a HashMap of sliding regionWindows for a vcf file with
    * the chromosome number as a key. The other input is a String returned from
    * a menu option picked by the user to describe the method they wanted.
    * If no method was picked, then the method will be set to default.
    */
    
    public HashMap<String, HashMap<Integer, ArrayList<Double>>> CalculateWindows(HashMap finalHS, String method, String regionSizeInput /*PropertyDescriptor.Listener windowInput*/) { 
        
        HashMap<String, HashMap<Integer, ArrayList<Double>>> values = new HashMap<String, HashMap<Integer, ArrayList<Double>>>(); //to be returned
        Iterator finalHSiter = finalHS.keySet().iterator(); //iterate through the regionWindows chromosomes
        
        
                if(method.equals("Homozygosity Mapping")) {
                    //use this Homozygosity Mapping method
                    //INSERT METHOD HERE
                    //Note that common variants do not need to be run for this.
                }
                else if (method.equals("Allelic Distance")) {
                    //use Allelic Distance Mapping method
                    //USE METHOD HERE
                    //Use F2 WT and mutant pools.
                }
                else if (method.equals("MAF Estimation")) {
                    //use MAF Estimation method
                    //USE METHOD HERE
                    //MAFCalculation mafe = new MAFCalculation(); //not complete yet
                    SlidingWindows t = new SlidingWindows();
                    values = t.freqFinder(finalHS);
                
                } else {
                    //use default method for that mapping population.
                    //USE METHOD HERE
                    //Call MAF twice
                }
            
            /*for (int i = 0; i<=windowSize; i++) { //for each value in the window
                float value = (float) finalHS.get(i); //get the value of each item in the window
                windowAvg = windowAvg + value; //add the value to the running sum
            */
        
            System.out.println("finished");
        return values;
        }
}
